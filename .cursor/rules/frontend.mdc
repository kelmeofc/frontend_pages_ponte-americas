---
alwaysApply: true
description: Advanced frontend development rules focusing on Clean Code, type mapping, and variant system
---

## Project Architecture & Structure


# Frontend Architecture Guide - Next JS 15 

## Project Overview
Please always refer to #file:../pandami.mdc for project specific context.

## When creating new sections from briefing or from scratch
Please consider refer to #file:../uxpilot.mdc for best pratices envolving interface generation.

## Fonts

When modifying font configuration, reference #file:globals.css #file:layout.tsx #file:tailwind.config.js as fonts are configured in these files. Ensure consistency to avoid build errors. Follow Clean Code principles and development best practices.

- Global styles already define Fahkwang for h1, h2, h3 and Ubuntu at :root
- Prefer using project-defined fonts unless specifically needed otherwise
- Avoid 'font-['Fahkwang']' or 'font-['Ubuntu']' in Tailwind classes - global classes are already defined
- Use TailwindCSS utility classes for additional styling (font weight, size, spacing)

## Styling Guidelines

- Always prefer TailwindCSS for styling, avoid pure CSS
- Use TailwindCSS CSS variables from "#file:@/styles/globals.css" for backgrounds, foregrounds, primary colors, and gradients
- Maintain visual consistency with TailwindCSS utility classes
- Check existing sections for styling and semantic structure consistency
- Follow componentization patterns, creating reusable components when needed
- Design responsively from the start using TailwindCSS utility classes
- Always use the &lt;section&gt; tag for new page sections
- Define an id for each section (lowercase, no spaces) - e.g., id="pricing"
- Wrap section content with &lt;Container&gt; for consistent alignment and spacing
- Use descriptive titles with appropriate heading tags (&lt;h2&gt; or &lt;h3&gt;)
- Prefer CSS variables from "#file:@/styles/globals.css" for colors
- Use "lucide-react" icons for visual consistency; use simple-icons for brand/social media icons
- Use "neutral" gray color classes
- Style sections with TailwindCSS utility classes matching overall design
- Use Primary Button for primary actions and Secondary Button for secondary actions
- **Utility-First**: Tailwind CSS with custom CSS variables
- **Component Variants**: class-variance-authority for component styling
- **Conditional Classes**: clsx and tailwind-merge via `cn()` utility
- Prioritize using styles from variables defined in `globals.css` for accent, primary, secondary, background, text colors
- Use Tailwind classes directly in components when no corresponding variable exists in `globals.css`
- For consistent colors, use variables defined in globals.css
- Main scheme: Dark background (#0F0E0D), light text (#F7F7F7), green highlight (#27D182)
- Main gradient: Blue (#017DDD) → Green (#27D182) → Yellow (#FAD007) with stops at 0%, 52%, 100%

## Core Technologies

- **Next.js 15**: React application with App Router
- **next-intl**: Internationalization system for multi-language support (pt/en)
- **TailwindCSS**: Styling with custom color scheme
- **Radix UI**: Accessible UI components
- **Lucide Icons**: Icon library used throughout the application


### Type Definitions (`src/@types/`)

- Centralized TypeScript interfaces and types

- Naming convention: `I[EntityName].ts` (e.g., `IUser.ts`, `IAuthentication.ts`)

- Contains business domain types like authentication, authorization, pagination, etc.

  

### App Router (`src/app/`)

```

src/app/

├── (private)/              # Protected routes (requires authentication)

│   ├── dashboard/          # Main dashboard with dynamic [id] routes

│   └── visagism/           # Visagism features with forms and [id] routes

├── (public)/               # Public routes (no authentication required)

│   ├── auth/               # Authentication pages (sign-in, sign-up)

│   └── free-trial/         # Free trial flow with gender selection

├── globals.css             # Global styles and Tailwind imports

├── layout.tsx              # Root layout with fonts and toast provider

└── page.tsx                # Home page

```

  

### Components (`src/app/_components/`)

```

src/app/_components/

├── pages/                  # Page-specific components

├── sections/               # Reusable section components

├── svg/                    # Custom SVG components

└── ui/                     # shadcn/ui components (auto-generated)

```

  

### Utilities (`src/lib/`)

- `utils.ts` - Utility functions including:

  - `cn()` for className merging with Tailwind

  - Brazilian mobile phone validation and formatting

  - Date formatting for Brazilian locale

  - Base64 to File conversion utilities

  

### Server Layer (`src/server/`)

```

src/server/

├── actions/                # Server actions

├── axios/                  # Axios interceptors and configuration

├── services/               # API service layer

├── api.ts                  # Main API client with interceptors

└── response-codes.ts       # HTTP response code definitions

```

  

### State Management (`src/stores/`)

- Zustand stores only for persistence, not for fetch like SWR

- Example: `user.store.ts` for user authentication state

  

## Architectural Patterns

  

### Route Organization

- **Route Groups**: `(private)` and `(public)` for authentication-based organization

- **Dynamic Routes**: `[id]` pattern for entity-specific pages

- **Nested Layouts**: Leverage Next.js App Router layout system

  

### Component Organization

- **UI Components**: Auto-generated shadcn/ui components in `components/ui/`

- **Page Components**: Specific to individual pages in `components/pages/`

- **Section Components**: Reusable across multiple pages in `components/sections/`

  

### State Management

- **Global State**: Zustand with persistence for user data

- **Form State**: React Hook Form with Zod validation

- **Server State**: Axios with custom interceptors for API communication

  

### Styling Approach

- **Utility-First**: Tailwind CSS with custom CSS variables

- **Component Variants**: class-variance-authority for component styling

- **Conditional Classes**: clsx and tailwind-merge via `cn()` utility


### Design Patterns

We follow Atomic Design and Clean Architecture principles:

#### 1. Atomic Design

Components organized by complexity hierarchy:
- **Atoms**: Basic components like buttons, inputs, icons (`@/app/_components/atoms/`)
- **Molecules**: Combinations of atoms forming simple functional components
- **Organisms**: Complex UI sections like headers, footers, etc.
- **Templates**: Layouts defining structure without specific content
- **Pages**: Templates populated with real data for user interaction

#### 2. Container-Presentational Pattern

Separation of business logic components (containers) from pure presentation components:
- **Container Components**: Handle logic, state, and requests
- **Presentational Components**: Focus only on rendering UI based on props

#### 3. Data Fetching Patterns

Using Next.js recommended data fetching patterns:
- **Server Components**: Prioritize server-side data fetching when possible
- **Parallelization**: Use parallel requests when appropriate
- **Fetch Where Needed**: Fetch data in the component that needs it, leveraging Next.js automatic memoization

## Patterns & Conventions

## General Instructions/Guidelines
These are architectural instructions that you should follow to create new React components/pages using the NextJS framework.

Every component created should follow the conventions and patterns established in this project, including folder structure, file naming, and coding styles.

### Naming Convention
File and folder names should be descriptive and follow the kebab-case convention and should be written in English. For example:
- Components: `component-name.tsx`
- Pages: `page-name/page.tsx`

### Architecture Structure
When creating components should be modularized and organized according to their responsibilities. Here is the full file structure:

- View: `component.view.tsx` 
- Model: `component.model.ts`
- Type: `component.type.ts` (only when necessary)
  
Each file has its own responsibility within the component lifecycle. View files are responsible for component presentation, Model handles business logic and interaction logic, and Type defines the types used (component-specific types).

You should use full structure for:
- Organisms and Pages (complex components)
- Components with business logic
- Reusable, testable components

Simplify for atoms/molecules:
- Single .tsx file if no logic
- Add .type.ts only if types are reused


// page.tsx - Orchestrator/Entry Point
// - Fetches server data (if RSC)
// - Composes view 

// component.model.ts - Business/Interaction Logic
// - Custom hooks (useState, useEffect, etc.)
// - Client-side state management
// - Data transformations, calculations
// - Event handlers logic
// - Used in views

// component.view.tsx - Pure Presentation
// - TSX only Client Component
// - Receives props, renders UI
// - No logic beyond conditional rendering

For pages, you should create their components inside ('@/app/_components/pages/**') follow the file organization pattern when necessary.

- View: `page.view.tsx`
- Model: `page.model.ts` 
- Type: `page.type.ts` (only when necessary, like validation schemas, data interface, enums or forms validation);
  
Then,

- Import the view in the respective `page.tsx` in app router, either (private) or (public).



## Best Practices

### Components

1. **Naming**: Use PascalCase for components and camelCase for functions/variables, clear boundaries between layers
2. **Organization**: Each component should have its own directory when needed
3. **Typing**: Use TypeScript to explicitly define props with interfaces and maps
4. **Props**: Destructure props and use default values when applicable
5. **Server vs Client**: Prefer Server Components when no state or interactivity is needed
6. **Modularization**: Keep components small and focused on single responsibility

```tsx
// Example component structure
// @/app/_components/feature/FeatureName/FeatureName.tsx

import styles from './FeatureName.module.css';

export interface IFeatureName {
  prop1: string;
  prop2?: number;
}

export default function FeatureName({ prop1, prop2 = 0 }: IFeatureName) {
  return (
    <div className={styles.container}>
      <h3>{prop1}</h3>
      <p>{prop2}</p>
    </div>
  );
}
```

### Performance

1. **Lazy Loading**: Use dynamic imports for large or rarely used components
2. **Images**: Optimize images using `next/image` component
3. **Memoization**: Use `useMemo` and `useCallback` to prevent unnecessary re-renders
4. **Server Components**: Prioritize Server Components to reduce client-side JavaScript

### SEO & Accessibility

1. **Metadata**: Use appropriate metadata on each page
2. **Semantics**: Use semantic and appropriate HTML elements
3. **ARIA**: Add ARIA attributes and ALT text when needed for accessibility
4. **Contrast**: Ensure colors have sufficient contrast


## Global Types Organization

### Type Definitions (`src/types/`)

- **Centralized TypeScript interfaces and types**
- **Naming convention**: `I[EntityName].ts` (e.g., `IUser.ts`, `IAuthentication.ts`)
- **Contains business domain types** like authentication, authorization, pagination, etc.

### When to Use Global Types

#### ✅ **Use Global Types When:**
- **Cross-component usage**: Types used in multiple components/pages
- **API responses**: Server response interfaces and data structures
- **Business domain entities**: User, Organization, Plan, Report, etc.
- **Shared interfaces**: Common props, form data, or state structures
- **Reusable types**: Types that represent core business concepts

#### ❌ **Don't Use Global Types When:**
- **Component-specific props**: Simple props used only in one component
- **Local interfaces**: Types specific to a single component's logic
- **Temporary types**: Types used only during development/testing
- **Implementation details**: Internal component state or helper types

### Global Types Structure

```typescript
// ✅ GOOD: Global type for business entity
// src/types/IUser.ts
export interface IUser {
    id: number;
    name: string;
    email: string;
    profile_image?: string;
    plan?: string;
    credits?: number;
}

// ✅ GOOD: Global type for API response
// src/types/IAuthentication.ts
export interface IAuthenticationAction {
    session_id: number;
    session_token: string;
    details: {
        id: number;
        name: string;
        email: string;
    }
}

// ❌ BAD: Component-specific props in global types
// Don't put this in src/types/
interface ButtonProps {
    variant: 'primary' | 'secondary';
    size: 'sm' | 'md' | 'lg';
}
```

### Naming Conventions

- **File naming**: `I[EntityName].ts` (e.g., `IUser.ts`, `IAuthentication.ts`)
- **Interface naming**: `I[EntityName]` (e.g., `IUser`, `IAuthentication`)
- **Action interfaces**: `I[EntityName]Action` (e.g., `ICreateUserAction`)
- **Response interfaces**: `I[EntityName]Response` (e.g., `IGenerateHairstylesResponse`)

### Import Strategy

```typescript
// ✅ GOOD: Import from global types
import { IUser, IAuthentication } from '@/types';

// ✅ GOOD: Import specific interfaces
import type { IUser } from '@/types/IUser';

// ❌ BAD: Don't create global types for component-specific needs
// Keep component props local to the component
```

### Type Organization Rules

1. **Business Domain First**: Organize by business domain (User, Organization, Plan, etc.)
2. **Single Responsibility**: Each type file should represent one business concept
3. **Consistent Naming**: Follow the `I[EntityName]` pattern consistently
4. **Documentation**: Add JSDoc comments for complex types
5. **Versioning**: Consider breaking changes when modifying global types

### Examples of Global Types

```typescript
// ✅ Authentication & Authorization
// src/types/IAuthentication.ts
// src/types/IAuthorization.ts

// ✅ Business Entities  
// src/types/IUser.ts
// src/types/IOrganization.ts
// src/types/IPlan.ts

// ✅ API & Data
// src/types/IPagination.ts
// src/types/IFile.ts
// src/types/IReport.ts

// ✅ Application State
// src/types/IFormStep.ts
// src/types/IHookFormReturn.ts
```

### Best Practices

1. **Prefer composition over inheritance** in type definitions
2. **Use optional properties** (`?`) for non-required fields
3. **Group related types** in the same file when they belong to the same domain
4. **Export types individually** for better tree-shaking
5. **Use type aliases** for complex union types
6. **Keep types focused** on business logic, not implementation details

This approach ensures type safety, reusability, and maintainability across the entire application.

## Workflows

### Local Development

```bash
# Install dependencies
pnpm add

# Start development server
pnpm run dev

# Build for production
pnpm run build

```

### Adding New Sections/Components

1. Determine if component should be Server or Client Component
2. Create component in `@/app/_components/`
3. Add translation strings in `messages/en.json` and `messages/pt.json`
4. Prioritize using styles from variables defined in `globals.css`
5. Import and use component in relevant pages

### Modifying Styles

- Prioritize using styles from variables defined in `globals.css` for accent, primary, secondary, background, text colors
- Use Tailwind classes directly in components when no corresponding variable exists in `globals.css`
- For consistent colors, use variables defined in globals.css
- Main scheme: Dark background (#0F0E0D), light text (#F7F7F7), green highlight (#27D182)
- Main gradient: Blue (#017DDD) → Green (#27D182) → Yellow (#FAD007) with stops at 0%, 52%, 100%

## Scalability & Maintenance

As the project grows, follow these practices to ensure scalability and maintainability:

### Clean & Readable Code

1. **Naming Conventions**: Maintain consistency in file, component, and function naming
2. **Comments**: Document complex or non-intuitive code
3. **Formatting**: Use formatters like Prettier to maintain consistency
4. **Refactoring**: Regularly refactor to improve code quality

### Performance Monitoring

1. **Lighthouse**: Run regular performance tests with Lighthouse
2. **Bundle Size**: Monitor JavaScript bundle size to avoid excessive growth
3. **Web Vitals**: Track metrics like CLS, FID, and LCP
4. **Server Rendering**: Use Server Components to reduce client workload

### Testing

1. **Unit Tests**: Write tests for isolated components and functions
2. **Integration Tests**: Test interaction between different system parts
3. **UI Tests**: Verify component appearance and behavior
4. **Accessibility Tests**: Ensure site accessibility using Playwright MCP

### MCP (Model-Centric Programming)

1. **Firecrawl**: For online site research and data extraction in markdown format
2. **Playwright**: For end-to-end UI and accessibility testing

## Copywriting & Content Strategy

### Voice Tone & Writing Style

- **Dave Gerhardt Style**: Direct, conversational, and results-oriented
- **Voice Tone**: Confident, innovative, professional yet accessible, inspiring
- **Key Characteristics**:
  - Clear and direct language
  - Focus on innovation, growth, and sustainable results
  - Storytelling to illustrate digital transformations
  - Selective use of rhetorical questions for engagement
  - Incorporation of innovation and sustainability elements

### Text Structure

1. **Titles & Headers**:
   - Direct and benefit-oriented
   - Preferably under 60 characters
   - Include relevant SEO keywords

2. **Body Text**:
   - Short paragraphs (max 3-4 lines)
   - Use lists and bullets for readability
   - Clear information hierarchy (inverted pyramid)

3. **CTAs (Calls to Action)**:
   - Action verbs in imperative form
   - Create sense of urgency when appropriate
   - Emphasize value user will receive

### Section Guidelines

- **Home Page**: Focus on communicating Kelme's vision and differentiators
- **About Us**: Storytelling about agency history and values
- **Services**: Highlight benefits before technical features
- **Portfolio**: Results-oriented narrative for each case study
- **Contact**: Welcoming and accessible tone

## Visual Identity

### Color Palette

- **Green** (#27D182): Primary highlight color, represents growth and innovation
- **Blue** (#017DDD): Complementary color, represents trust and professionalism
- **Yellow** (#FAD007): Support color, represents creativity and optimism
- **White** (#F7F7): Secondary color, represents clarity and space
- **Black/Dark Gray** (#0F0E0D): Background color, represents solidity and elegance
- **Secondary Green** (#3F9E59): Support color for green areas
- **Light Gray** (#D7D7D7): Color for secondary neutral elements

**Color Usage:**
- Green: Highlight elements, CTAs, main accents
- Blue: Secondary interactive elements, highlight sections
- Yellow: Notification elements, tertiary highlights
- White: Main text, breathing space areas
- Black/Dark Gray: Backgrounds, secondary text

### Brand Symbolism & Elements

- **Key Concepts**: Growth, innovation, fluidity, vision beyond horizon, superior perspective
- **Logo**: Eagle with head turned left, visible claws, with elements highlighted in green-blue gradient
- **Visual Metaphors**: Altitude, expansion, freedom, strategic vision, digital transformation

### Design Components

- **Iconography**:
  - Main library: Lucide Icons for interface
  - Simple Icons for social media and companies
  - Minimalist style with thin lines
- **Cards**: Futuristic design with glassmorphism effect and green-blue gradient accents
- **Buttons**: Rounded with green-to-blue gradients or green borders (radius: 8px)
- **Typography**:
  - Main font: Satoshi (weights: 300, 400, 500, 700)
  - Headings: Rubik
  - Body: Satoshi Regular/Light

### Image Guidelines

- **Photographic Style**: High-resolution images with contrasting tones
- **Treatment**: Light overlay with green-blue gradient on images for visual unity
- **Visual Themes**: Modern environments, technology, professionalism, innovation, sustainability
- **Composition**: Generous negative space, rule of thirds, ascending directional lines

### Animations & Interactions

- **Principles**: Smooth, elegant, with functional purpose
- Use GSAP library for animations
- **Transitions**: Natural easing curves, average duration 300-500ms
- **Hover**: Subtle scale effects (1.02-1.05) with green highlight (#27D182)
- **Scroll**: Fade and slide animations for elements entering viewport
- **Microinteractions**: Visual feedback for user actions with green-blue gradient accents
- **Gradients**: Fluid transitions between blue (#017DDD), green (#27D182), and yellow (#FAD007)

### Responsive Design

- **Approach**: Mobile-first with strategic breakpoints
- **Main Breakpoints**:
  - Mobile: < 640px
  - Tablet: 640px - 1024px
  - Desktop: > 1024px
  - Large Desktop: > 1280px
- **Techniques**:
  - Flexible units (rem, %, vh/vw)
  - Grid and Flexbox for adaptive layouts
  - Content prioritized by relevance on smaller screens
- **Images**: Responsive with srcset for different pixel densities
- **Touch**: Generous touch areas (minimum 44x44px) for mobile interfaces

### Accessibility Guidelines

- **Compliance**: Follows WCAG 2.1 level AA guidelines
- **Color Contrast**: Minimum 4.5:1 for standard text, 3:1 for large text (green #27D182 should be used on larger elements or with reinforced contrast)
- **Keyboard Navigation**: All interactive elements accessible via keyboard
- **ARIA Attributes**: Used to improve screen reader experience
- **Focus States**: Visible and consistent with green outlines (#27D182)
- **Alt Text**: All images have appropriate descriptions
- **Semantic Structure**: Proper use of headings (H1-H6) and HTML5 elements
- **Forms**: Explicit labels and accessible error messages
- **Testing**: Regular verification with automated tools and manual testing

### Development Principles

1. **DRY (Don't Repeat Yourself)**: Avoid code duplication
2. **KISS (Keep It Simple, Stupid)**: Keep solutions simple and straightforward
3. **YAGNI (You Aren't Gonna Need It)**: Don't add functionality before needing it
4. **Composition over Inheritance**: Prefer component composition over inheritance
5. **Immutability**: Treat data as immutable to avoid side effects

This guide serves as a reference for maintaining code consistency and quality in the Kelme Studio project. The practices and patterns described here should be followed by all team members to ensure efficient and sustainable development.